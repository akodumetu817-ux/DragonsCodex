//
//  GeminiService.swift
//  Melbe
//
//  Created by D K on 09.05.2025.
//

import Foundation


class GeminiService {
    private let apiKey = "AIzaSyDeKZRT21892LO6NjoSWdWgq3OfXeiOG1c"
    private let modelName = "gemini-2.0-flash"
    private lazy var baseURL = "https://generativelanguage.googleapis.com/v1/models/\(modelName):generateContent"
    
    enum GeminiError: Error, LocalizedError {
        case invalidUrl
        case networkError(Error)
        case apiError(String)
        case decodingError(Error)
        case noContentGenerated
        
        var errorDescription: String? {
            switch self {
            case .invalidUrl: return "Invalid API URL."
            case .networkError(let error): return "Network error: \(error.localizedDescription)"
            case .apiError(let message): return "API error: \(message)"
            case .decodingError(let error): return "Decoding error: \(error.localizedDescription)"
            case .noContentGenerated: return "Model didn't generate any content."
            }
        }
    }
    
    // MARK: - Request Structures
    struct GeminiRequest: Encodable {
        let contents: [Content]
    }
    
    struct Content: Encodable {
        let parts: [Part]
    }
    
    struct Part: Encodable {
        let text: String
    }
    
    // MARK: - Response Structures
    struct GeminiResponse: Decodable {
        let candidates: [Candidate]?
    }
    
    struct Candidate: Decodable {
        let content: ResponseContent?
    }
    
    struct ResponseContent: Decodable {
        let parts: [ResponsePart]?
    }
    
    struct ResponsePart: Decodable {
        let text: String?
    }
    
    // MARK: - Generate Content
    func generateDnDContent(type: ContentType, prompt: String) async -> Result<String, GeminiError> {
        print("Starting generation for type: \(type.rawValue) with prompt: \(prompt)")
        
        guard let url = URL(string: "\(baseURL)?key=\(apiKey)") else {
            print("Invalid URL constructed")
            return .failure(.invalidUrl)
        }
        
        let fullPrompt = createPrompt(for: type, userPrompt: prompt)
        print("Full prompt sent to Gemini:\n\(fullPrompt)")
        
        let requestPayload = GeminiRequest(
            contents: [Content(parts: [Part(text: fullPrompt)])]
        )
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        do {
            request.httpBody = try JSONEncoder().encode(requestPayload)
        } catch {
            print("Failed to encode request payload: \(error)")
            return .failure(.decodingError(error))
        }
        
        do {
            let (data, response) = try await URLSession.shared.data(for: request)
            
            guard let httpResponse = response as? HTTPURLResponse else {
                print("Invalid HTTP response")
                return .failure(.networkError(NSError(domain: "", code: 0, userInfo: [NSLocalizedDescriptionKey: "Invalid HTTP response"])))
            }
            
            print("Received HTTP status code: \(httpResponse.statusCode)")
            
            guard httpResponse.statusCode == 200 else {
                let errorBody = String(data: data, encoding: .utf8) ?? "No error body"
                print("API error with status \(httpResponse.statusCode): \(errorBody)")
                return .failure(.apiError("HTTP Status \(httpResponse.statusCode). Body: \(errorBody)"))
            }
            
            let geminiResponse: GeminiResponse
            do {
                geminiResponse = try JSONDecoder().decode(GeminiResponse.self, from: data)
            } catch {
                print("Failed to decode Gemini response: \(error)")
                return .failure(.decodingError(error))
            }
            
            guard let candidate = geminiResponse.candidates?.first,
                  let responsePart = candidate.content?.parts?.first,
                  let resultText = responsePart.text else {
                print("No content generated by model")
                return .failure(.noContentGenerated)
            }
            
            print("Successfully received response from Gemini")
            return .success(resultText)
            
        } catch {
            print("Network request failed: \(error)")
            return .failure(.networkError(error))
        }
    }
    
    private func createPrompt(for type: ContentType, userPrompt: String) -> String {
        let baseInstruction = """
        You are a professional Dungeons & Dragons content generator. 
        The user will provide a description of what they need, and you must generate content strictly following the requested format.
        """
        
        let specificInstructions: String
        let format: String
        
        switch type {
        case .quest:
            specificInstructions = """
            Generate a D&D quest with the following elements:
            - Plot: A brief description of the situation or problem
            - Goal: What the adventurers need to accomplish
            - Twist: An unexpected revelation or complication
            """
            format = """
            Plot: [description]
            Goal: [what needs to be done]
            Twist: [unexpected element]
            """
            
        case .location:
            specificInstructions = """
            Generate a D&D location with the following elements:
            - Type: The kind of location (e.g., ancient temple, haunted forest)
            - Atmosphere: The general feeling and sensory details
            - Details: Specific features of the location
            """
            format = """
            Type: [location type]
            Atmosphere: [sensory details]
            Details: [specific features]
            """
            
        case .npc:
            specificInstructions = """
            Generate a D&D NPC with the following elements:
            - Name: The character's name
            - Appearance: Physical description
            - Behavior: How the character acts
            - Motivation: What drives the character
            """
            format = """
            Name: [character name]
            Appearance: [physical description]
            Behavior: [behavior traits]
            Motivation: [character motivation]
            """
        }
        
        return """
        \(baseInstruction)
        
        \(specificInstructions)
        
        The user's request is: "\(userPrompt)"
        
        Generate content strictly in this format (include the labels exactly as shown):
        \(format)
        
        Do not include any additional commentary, explanations, or text outside of this format.
        """
    }
    
    enum ContentType: String {
        case quest = "Quest"
        case location = "Location"
        case npc = "NPC"
    }
}
